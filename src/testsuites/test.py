import logging
import os
from abc import ABC, abstractmethod
from enum import IntEnum
from dataclasses import dataclass, field
from typing import Optional
from protosuites.proto_info import IProtoInfo
from var.global_var import g_root_path


class TestType(IntEnum):
    throughput = 0
    latency = 1
    jitter = 2
    rtt = 3
    sshping = 4
    scp = 5


# add mapping for the test type
test_type_str_mapping = {
    TestType.throughput: "iperf3",
    TestType.latency: "latency",
    TestType.jitter: "jitter",
    TestType.rtt: "rtt",
    TestType.sshping: "sshping",
    TestType.scp: "scp"
}


@dataclass
class TestConfig:
    """
    TestConfig is a dataclass that holds the configuration for the test.
    interval: The interval time for the test.
    interval_num: The number of intervals.
    packet_size: The size of the packet to be sent.
    packet_count: The number of packets to be sent.
    test_type: The type of test to be performed.
    client_host: The host id of the client.
        for iperf, iperf client will be run on this host.
        if None, iperf client will be run on all hosts.
    server_host: The host id of the server.
        for iperf, iperf server will be run on this host.
        If None, iperf server will be run on all hosts.
    allow_fail: A boolean value that indicates whether the test can fail.
    """
    name: str = field(default="")  # name of test tool
    test_name: str = field(default="")  # name of test
    interval: Optional[float] = field(default=1.0)
    interval_num: Optional[int] = field(default=10)
    parallel: Optional[int] = field(default=1)  # Number of parallel streams
    packet_size: Optional[int] = field(default=1024)
    packet_count: Optional[int] = field(default=10)
    packet_type: Optional[str] = field(default="tcp")  # udp or tcp
    file_size: Optional[int] = field(default=1)  # for scp, default 1 MB
    bitrate: Optional[int] = field(default=0)
    # target bitrate in #[KMG][/sec (0 for unlimited)(default 1 Mbit/sec for UDP, unlimited for TCP)
    test_type: Optional[TestType] = field(default=TestType.throughput)
    client_host: Optional[int] = field(default=None)
    server_host: Optional[int] = field(default=None)
    allow_fail: Optional[bool] = field(default=False)
    args: Optional[str] = field(default="")  # args for test tool


@dataclass
class TestResult:
    """
    TestResult is a dataclass that holds the result of the test.
    is_success: A boolean value that indicates whether the test was successful.
    record: The record file generated by the test which contains the test results.
        file name pattern: <class_name>_<test_type>_<client_host>_<server_host>.log
    """
    is_success: bool = field(default=False)
    pattern: str = field(default="")
    record: str = field(default="")  # log file
    result_dir: str = field(default=f"{g_root_path}")


class ITestSuite(ABC):
    def __init__(self, config: TestConfig) -> None:
        self.base_name = ""
        self.config = config
        self.result_dir = f"{g_root_path}test_results/{self.config.test_name}/"
        if not os.path.exists(f"{self.result_dir}"):
            os.makedirs(f"{self.result_dir}")
        if self.config.test_type is not None:
            self.result = TestResult(
                False, pattern=f"{self.__class__.__name__}_{self.config.name}_{self.config.packet_type}"
                f"_{test_type_str_mapping[self.config.test_type]}"
                f"_h{self.config.client_host}_h{self.config.server_host}.log",
                record="", result_dir=self.result_dir)
        else:
            logging.error("Test type is not set. %s", self.config.test_type)
            self.result = TestResult(False, pattern="", record="")

    def name(self) -> str:
        return self.config.name

    @abstractmethod
    def post_process(self) -> bool:
        pass

    @abstractmethod
    def pre_process(self) -> bool:
        pass

    @abstractmethod
    def _run_test(self, network: 'INetwork', proto_info: IProtoInfo) -> bool:  # type: ignore
        pass

    def run(self, network: 'INetwork', proto_info: IProtoInfo) -> TestResult:  # type: ignore
        if self.result.pattern == "":
            return self.result
        if proto_info.get_protocol_version() != "" and proto_info.get_protocol_version() != 'latest':
            if 'tcp' not in proto_info.get_protocol_name():
                self.base_name = proto_info.get_protocol_name().upper() + "-" + \
                    proto_info.get_protocol_version()
            else:
                self.base_name = proto_info.get_protocol_name().upper()
        else:
            self.base_name = proto_info.get_protocol_name().upper()
        self.result.record = self.result.result_dir + \
            self.base_name + "_" + self.result.pattern
        self.result.is_success = self.pre_process()
        # checking for non-distributed protocols
        if not proto_info.is_distributed():
            if self.config.client_host is None:
                logging.error(
                    "Test non-distributed protocols without client host is not supported.")
                return self.result
            if self.config.server_host is None:
                logging.error(
                    "Test non-distributed protocols without server host is not supported.")
                return self.result
        if not self.result.is_success:
            return self.result
        if not self.__validate_host_config(network):
            self.result.is_success = False
            return self.result
        self.result.is_success = self._run_test(network, proto_info)
        if not self.result.is_success:
            logging.error("ITestSuite %s failed.", self.config.test_name)
            return self.result
        self.result.is_success = self.post_process()
        if not self.result.is_success:
            return self.result
        return self.result

    def is_succeed(self) -> bool:
        return self.result.is_success

    def type(self) -> TestType:
        return self.config.test_type if self.config.test_type is not None else TestType.throughput

    def get_result(self) -> TestResult:
        return self.result

    def get_config(self) -> TestConfig:
        return self.config

    def __validate_host_config(self, network: 'INetwork') -> bool:  # type: ignore
        hosts = network.get_hosts()
        if hosts is None:
            return True
        hosts_num = len(hosts)
        if self.config.client_host is not None and self.config.server_host is not None:
            if self.config.client_host >= hosts_num or self.config.server_host >= hosts_num:
                logging.error("Invalid client or server host id, client: %d, server: %d",
                              self.config.client_host, self.config.server_host)
                return False
        return True
